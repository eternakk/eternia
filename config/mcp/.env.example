# MCP environment variables template for Eternia
# Copy this file to `.env` in the same directory and fill in the values.
# These variables are referenced by your MCP servers config using the env:// scheme.

# ───── GitHub (read + write PRs/issues via github-mcp) ─────
# Token should be a fine-grained or PAT with repo:read, issues:write, pull_requests:write as needed.
GITHUB_TOKEN_RO=

# Optional: GHCR login to pull images from ghcr.io (needed if you see 'denied')
# Set your GitHub username and a token with read:packages (you can reuse the GitHub PAT if it has that scope).
# If provided, the Docker wrappers can auto-login to ghcr.io to pull images.
GHCR_USERNAME=
GHCR_TOKEN=

# ───── SQLite (dev) ─────
# No env vars needed. The server runs with: --db ./artifacts/dev.sqlite3 --mode ro
# Ensure the file exists at artifacts/dev.sqlite3 if you plan to connect in read-only mode.

# ───── Postgres (read-only) ─────
PGHOST=
PGPORT=5432
PGDATABASE=
PGUSER_RO=
PGPASSWORD_RO=
# SSL mode defaults to require per your config; change if your cluster uses a different policy.
PGSSLMODE=require

# ───── E2B Sandbox (exec capability) ─────
E2B_API_KEY=

# ───── AWS S3 (read-only) ─────
AWS_REGION=
AWS_ACCESS_KEY_ID_RO=
AWS_SECRET_ACCESS_KEY_RO=

# ───── Optional: Eternia local tokens (not required for MCP, useful for API/UI) ─────
# If you want to align with Eternia’s dev auth, you can optionally set one of these.
# The backend accepts ETERNA_TOKEN or VITE_ETERNA_TOKEN; otherwise it generates and writes artifacts/auth_token.txt
ETERNA_TOKEN=
VITE_ETERNA_TOKEN=
